# C++11新特性

* 允许用 `nullptr` 代替 0 或者 `NULL`
* Automatic Type Deduction with `auto` 用`auto`类型可以不需要指定变量类型，可由编译器自动进行推断， eg `auto i = 42` (推荐在type很长或者很发杂的时候用 auto， 比如迭代器)
* **Uniform Initialization** 任何初始化都可以用一种 **one common syntax** 来进行初始化 (使用 **大括号**) 
eg: `int values[]{1,2,3}`
    `vector<int> v{2,3,4,5}`
    `complex<double> c{4.0,3.0}`
    `int* p{}` 这时候 q会被初始化指向 nullptr
实现的原因是背后有 `initializer_list<T>` 和 `array<T,n>`的支持
* **initializer_list<T>** 采用这个可以实现函数参数个数不定，传给参数是 initializer_list 的也必须是一个 `initializer_list` 或者是`{...}`的形式，initializer_list是一个容器

* **explicit** for ctors taking more than one argument。 在 c++ 11 之前 **explicit** 关键字用在构造函数上可以让编译器强制不进行隐式转换(让用户必须显示地调用构造函数)，在c++11之前一般只有一个参数的构造函数才会进行隐式转换。但在c++11之后允许对有多个参数的构造函数也加上 **explicit** 关键词 使得其不进行隐式转换。（**explicit**用的比较少，这里可能表述的不是很准确）
* **rang-based for statement**, 允许使用` for( decl : coll)`语法， `coll`是一个容器，比如`vector` 或者是 `{1,2,3}`
* **=default, =delete** 原本在c++中 如果我们自行定义了一个`ctor`(构造函数),那么编译器就不会再给我们一个`default ctor`，但是现在如果加上了 `=default` 就可以重新获得编译器的默认构造函数 eg: `Foo()=default`。 `=default` 用在 **big three**函数上（构造 复制构造 析构)
`=delete` 表示不想要这个函数，可以用在任何函数上。比如可以用 `=delete`函数放弃编译器的默认复制构造函数（这样的好处是我们显示地拒绝了编译器的默认复制构造函数，不准让别人复制，可以用在**单例设计模式中**）

* **Alias Template(template typedef)**  别名模板，可以给模板指定别名.

## Uniform Initialization

当编译器看到 {t1,t2...tn}的时候会将其构造成为一个 `initializer_list<T>` 然后将其关联置一个 `array<T,n>`调用函数 （比如构造函数）时这个array内的元素可以被编译器逐一分解传递给函数，但如果函数的参数是一个 `initializer_list<T>`,调用者不能给予数个T参数，然后认为他们会被自动转化为一个`initializer_list<T>`传入。（如果函数构造函数的参数有一个参数是 `initializer_list<T>` 那么需要将一个`initializer_list<T>`传给它,这里涉及到`initializer_list<T>`的机制)

## initializer_list<>

example: 

```C++
class P
{
    public :
        p   (int a, int b){
            cout<< "P(int,int), a="<<a<<",b="<< b << endl;
        }   // P1
        P(initializer_list<int> initialist)
        {
            cout<< "P(initializer_list<int>), values= ";
            for(auto i : initialist)
                cout<< i << ' ' ;
            cout<<endl;
        }  //P2
}
P q{1,2}   // 会调用 P2这个函数， 如果没有 P2，编译器会先将 {1,2}组成一个 initializer_list（initializer背后是用array实现的） 然后再将其一个一个分解 最后会调用 P1这个函数
P p{1,2,3}; // 调用 P2

/*
    The initializer_list object refers to the elements of this array without containing them: copy an initializer lis t object produces another object referring o the same underlying elements, not to new copies of them.
*/
```

`initializer_list<T>` 的实现在源码中将一个 `指针`(迭代器)传递给 `array` 所以 `initializer_list<T>` 可以看成**不含有任何** 元素的 `array`。

`initializer_list` 改变了很多标准库的实现(包括算法库) 所以现在可以这么写了
`max({1,2,3,4}) // 4`

## range-based for statement

example:
```c++

// func1
for( int i: {1,2,3,4,5}){
    cout << i <<endl;
}

vector<double> vec;
...
// func2
for (auto elem : vec){
    cout<< elem << endl;
}

// func3
for( auto& elem : vec){
    elem *=3 ; 
    // 通过 这种语法+引用可以实现快速赋值,但是部分容器（关联式容器）不能通过迭代器改变其内容，比如 set \ unordered_set
}

/*
    for( decl : coll){
        statement; 
    }
    上述语法等价于
*/
for( auto _pos = coll.begin(), _end = coll.end(); _pos! = _end; ++ _pos){
    decl = *_pos ; // 取出迭代器内容;
    statement;
}
```

## **=default,=delete**

在C++中，一个类里面编译器会给类添加默认的 **构造，复制构造，析构** 函数（如果没有自己定义）。

什么类需要自己实现`big three`（构造，复制构造，析构）? 当这个类有指针变量的时候。 （涉及深拷贝和浅拷贝） 

`=default`: 只能用在 **构造函数，复制构造函数，析构函数** 上，但是注意，如果我们显示定义了一个**复制构造函数** 那么我们不能再使用 `=default` eg:`FOO(const FOO&) = default` 因为这样会导致二义性（编译器不知道用哪一个版本）。 `=default` 可以让我们再自己定义了构造函数之后，还能够拥有编译器提供的默认构造函数（可以省区一些写代码的功夫）

`=delete`: 删除某个函数，可以用来显示地删除 **默认构造函数，默认复制构造函数**, `=delete`可以作用于任何函数。`=delete`可以用在**单例设计模式**中，通过 delete掉默认的复制构造函数，让别人不能够复制（如果在C++11以前，可能要实现这个功能十分复杂，需要有一个复制构造函数是 **private**的基类，然后让子类继承这个基类来实现，c++中好像有一个 `boost::noncopyable`实现了一个把复制构造函数放在`private`的基类）

## **Alias Template(template typedef)**

eg:

```c++
template <typename T>
using Vec = std::vector<T,MyAlloc<T>>;
Vec<int> coll;
// 等价于
std::vector<int,MyAlloc<int>> coll;

```

ps:
使用 **macro**(宏) 和 **typedef** 都无法达到相同的效果
eg: `typedef std::vector<int,MyAlloc<int>> Vec` , 虽然可以直接用Vec但是无法指定参数
eg: `#define Vec<T> template<typename T> std::vector<T,MyAlloc<T>>`
    `Vec<int> 等价于 template<typename int> std::vector<int,MyAlloc<int>>` 很不自然（不像是在定义一个变量）

但是 不能对 **Alias Template** 进行**特化**或者**偏特化**

### alias template 实战

