# C++11新特性——标准库篇

## Rvalue reference 右值引用

> Rvalue references are a **new reference** type introduced in C++0x that help solve the porblem of **unnecessary copying** and enable **pefect forwarding**. When the **right-hand side** of an assignment is an **rvalue**, the the left-hand side object can **steal** resources from the right-hand side object **rather than** performing a separate allocation, thus enable **move semantics**
>

右值引用可以减少不必要的copy。当赋值操作的右手边是一个**右值**，可以**偷**右手边资源，而不需要非必要的拷贝。

### 左值和右值

* **左值 Lvalue**: 可以出现在 **operator=** 的左边，也就是变量(也可以放在右边)
* **右值 Rvalue**: 只能出现在 **operator=** 的右侧。也就是**临时对象**，临时变量没有名字。

eg 1: 

```c++
    int a =9;
    int b =4;
    a = b; //ok
    a+b = 42 // error ,a+b是右值
```

eg2 :

```c++
int foo(){return 5;}
...
int x = foo() ; // ok x是左值
int* p = &foo(); //Error，之前对右值无法取地址
fool() =7;        // error ,右值无法赋值
```

### 右值引用

右值引用可以减少不必要的copy。当赋值操作的右手边是一个**右值**，可以**偷**右手边资源，而不需要非必要的拷贝。

所谓的**偷**指的是指针的**浅拷贝**,直接进行指针赋值，进行**move**.

copy 操作 vs move 操作

![figure5](./resources/5.jpg) ![figure6](./resources/6.jpg)

在这种情况下为什么浅拷贝是被允许的?

* 临时变量本身不能够放在赋值符号的右边，所以临时变量被创建之后其内存里的内容不会被更改的，直接用指针指向临时变量的内存区域十分安全。
* 如果我们能够保证一个变量之后不再使用它，我们可以把左值当成右值(将使用移动构造函数).
  
  ```c++
    M c1(c);
    M c2(std::move(c1));
      c1.swap(c2);
    // 必须要保证 之后不再继续使用 c1
  ```

### 右值引用语法

```c++
iterator
insert(const_iterator __position, const value_type& x); //普通引用

iterator
insert(const_iterator __position, value_type&& __x); // 右值引用的语法， x是一个临时变量 或者 使用了 std::move

```

#### 右值引用的问题 unperfect forward

```c++
void process(int & i){
  cout<<"process(int&):"<<i<<endl;
}
void process(int && i){
  cout<<"process(int&&):"<<i<<endl;
}

void forward(int && i){
  cout<<"fowrard(int &&):"<<i<<",";
  process(i);
}

int a =0; 
porcess(a);// 调用 process(int &)
process(1)   // 调用 process(int &&)
process(move(a)); //调用 process(int &&)
fworard(2) ; // fworard(int&&):2, process(int&):2
fworard(move(a)) ; // fworard(int&&):0, process(int&):0
```

如上所述，RValue 经过 forward 再调用两外一个函数就变成了 LValue，原因是经过第一次 forward函数之后，原本的RValue有了参数名称，变成了左值(named object)，所以在forward内部调用了左值的版本.

#### Perfect Forwarding

> **Perfect forwarding** allows you to write a single function template that takes n arbitrary arguments and forwrds them **transparentlly** to **another arbitrary function**. The **nature** of the argument(modifiable,const,lvalue or **rvalue**) is preserved in this forwarding process
>

通过标准库提供的 std::forward实现 perfect forward

eg:

```c++
template<typename T1, typename T2>
void function A(T1&& t1, T2 && t2)
{
  functionB(std::forward<T1>(t1), std::forward<T2>(t2));
}

```

### move-aware class

eg:

```c++
class MyString
{
  private :
    char* _data;
    size_t _len;
    void __init_data(const char*s){
      _data = new char[_len+1];
      memcpy(_data,s,_len);
      _data[_len] ='\0';
    }
  public:
  //default constructor
  MyString():_data(NULL),_len(0){}
  // constructor
  MyString(const char* p):_len(strlen(p)){
    _init_data(p);
  }
  // copy constructor
  MyString(const MyString & str):_len(str._len){
    _init_data(str.data);
  }
  // move constructor 。移动构造函数必须加上 nonexcept 关键字
  MyString(MyString&& str) noexcept
  :_data(str._data), _len(str._len){
    // 上面的指针赋值是一个浅拷贝
    str._len =0; 
    str._data = NULL ; 
    //一定把原指针设成NULL
    // 否则可能导致临时变量销毁的时候
    //其析构函数把内存空间也销毁了， 
    //这不是我们想要的
    //设置成NULL要配合析构函数，判断
    //指针是不是NULL再delete
  }

  // copy assignment 
  MyString& operator= ( const MyString& str){
    if( this != &str){
      if(_data) delete _data; // 不是空指针才 delete
      len = str._len;
      _init_data(str.data); //COPY
    }else{

    }
    return *this
  }

  //move assignment
  MyString& operator=(MyString&& str) noexcept{
    // 先判断是不是自我赋值
    if(this !=&str){
      // 判断空然后释放原有的空间
      if(_data) delete _data; 
      _len = str._len;
      _data = str._data; //MOVE，浅拷贝
      // 下面部分同 move ctor，很重要
      str._len =0;
      str._data =NULL; //配合析构函数,重要
    }else{}
    return *this;
  }

  // dtor
  virtual ~MyString(){
    ++Dtor;
    if(_data){
      delete _data;
    }
  }
}
```